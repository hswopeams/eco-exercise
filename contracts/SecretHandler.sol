// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.17;

import "./Constants.sol";
import "./Killable.sol";
import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "hardhat/console.sol";

/**
 * @title SecretHandler
 * @author Heather Swope
 *
 * @notice Provides functionality allowing two parties to commit to a secret they agree on and to reveal that secret.
 */
contract SecretHandler is Killable, EIP712("SecretHandler", "1") {
    struct Secret {
        uint256 id;
        bytes32 message;
        uint256 blockNumber;
        address party1;
        address party2;
    }

    mapping(uint => Secret) public secrets;
    uint public nextSecretId;

    event SecretCommitted(uint256 indexed secretId, Secret secret, address indexed executedBy);
    event SecretRevealed(uint256 indexed secretId, bytes32 plainSecret, address indexed executedBy);


    /**
     * @notice Constructor
     * @dev Sets initial counter value;
     */
    constructor() {
        nextSecretId = 1;
    }

    /**
     * @notice Commits a secret that has been agreed upon by two parties. Either party can call this function, but the caller is assumed to be party1 in the signed struct. 
     * The transaction must be signed by the party2.
     * @dev Since the structured data being signed includes both parties' addresses, only 1 signature is required. This saves the gas it could take to verify two
     * signatures.
     * 
     * Emits a SecretCommitted event if successful.
     *
     * Reverts if:
     * - The hashedSecret is empty
     * - Party2 is the zero address
     * - Address of the recovered signer is the zero address
     * - Address of the recovered signer is not the same as party2 address
     * 
     * @dev The caller should call hashSecret first to generate a secret that is not in plain text.
     * @param hashedSecret the hash of a message, both parties' addresses, a secretId, and a salt
     * @param party2 the address of party 2
     * @param sigR - r part of party2's signature
     * @param sigS - s part of party2's signature
     * @param sigV - v part of party2's signature
     */
    function commitSecret(bytes32 hashedSecret, address party2, bytes32 sigR, bytes32 sigS, uint8 sigV) external { 
        require(hashedSecret !=  bytes32(0), INVALID_SECRET);
        require(party2 != address(0), INVALID_ADDRESS);

        //Assgin secret Id and increment
        uint256 secretId =  nextSecretId++;

        // Verify that party2 signed the message before storing secret
        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
            keccak256("Secret(uint256 id,bytes32 message,uint256 blockNumber,address party1,address party2)"),
            secretId,
            hashedSecret,
            0, // Will be set in this function
            msg.sender,
            party2)
        ));

        address signer = ECDSA.recover(digest, sigV, sigR, sigS);

        // ECDSA.recover checks for signer == address(0)) and reverts
        require(signer == party2, SIGNER_AND_SIGNATURE_DO_NOT_MATCH);

        // Store secret
        Secret memory secret = Secret({id: secretId, message: hashedSecret, blockNumber: block.number, party1: msg.sender, party2: party2});
        secrets[secretId] = secret;
       
        emit SecretCommitted(secretId, secret, msg.sender);
    }

    /**
     * @notice Reveals secret if called by one of the two parties to the secret and called in a block later than the commit transaction block.
     * @dev Deletes secret. Calls hashSecret to make sure revealed secret matches committed secret.
     * 
     * Emits an SecretRevealed event if successful.
     *
     * Reverts if:
     * - The caller is not one of the parties to the secret
     * - Current block number is not later than the block number in which the secret was committed
     * - Salt is empty
     * - Plain message is empty
     * - Secret Id is invalid
     * - Plain message passed in does not match the commited secret message
     * 
     * @param plainSecret - the plain text secret
     * @param salt -  salt generated by calling application
     * @param secretId Id of the stored secret
     */
    function revealSecret(bytes32 plainSecret, bytes32 salt, uint secretId) external {
        Secret memory secret = secrets[secretId];
        require(secret.id >= 1, INVALID_SECRET_ID); // Make sure there was actually a secret stored for this Id
        require(msg.sender == secret.party1 || msg.sender == secret.party2, CALLER_NOT_PARTY);
        require(block.timestamp > secret.blockNumber, REVEAL_TOO_SOON );
        require(salt != bytes32(0), INVALID_SALT);
        require(plainSecret != bytes32(0), INVALID_SECRET);
        require(hashSecret(plainSecret, salt) == secret.message, SECRETS_DO_NOT_MATCH);
      
        emit SecretRevealed(secretId, plainSecret, msg.sender);

        delete secrets[secretId];
    }

    /**
     * @notice Generate hash of plain text secret+ a salt passed in + contract address. This function keeps the secret private onchain.
     * Several components are used in the hash to mininimize the possibility of collisions with other parties or contract instances using the same plainSecret.
     * @param plainSecret - the plaintext secret message
     * @param salt salt generated by calling aplication
     * @return hashedSecret the hashed secret
     */
    function hashSecret(bytes32 plainSecret, bytes32 salt) public view returns (bytes32 hashedSecret) {
        require(salt != bytes32(0), INVALID_SALT);
        require(plainSecret != bytes32(0), INVALID_SECRET);
       
        hashedSecret = keccak256(abi.encodePacked(address(this), plainSecret, salt));
        //console.log("hashedSecret in hashSecret ");
        //console.logBytes32(hashedSecret);
    } 
}